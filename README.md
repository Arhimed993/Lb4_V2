[README.md](https://github.com/user-attachments/files/24131954/README.md)
# Анянов Кирилл ИТ-4 Лабораторная №4: ОБОБЩЕННЫЕ ТИПЫ

# Задание 1. Обобщенные типы. Типовые переменные, <>
## Задача 1.1: Обобщенная коробка
### Текст задачи
Создайте сущность Коробка, которая обладает следующими характеристиками:
• Может хранить один произвольный объект в один момент времени.
• Объект можно получить и разместить на хранение в любой момент времени.
• Если объект забирают из коробки – ссылку на этот объект необходимо обнулить.
• Если объект кладут в коробку, но она не пуста – необходимо выкинуть исключение.
• Имеет метод проверки на заполненность.
• Методы класса должны работать с тем типом данных, который был указан во время создания объекта.
Создайте Коробку которая может хранить целочисленное значение, разместите туда число 3. Передайте Коробку в какой-либо метод, извлеките значение, и выведите его на экран.

### Алгоритм решения
Создаем обобщенный класс Box<T> с одним полем для хранения объекта. Реализуем конструкторы для создания пустой и заполненной коробки. Разрабатываем методы put() для помещения объекта (с проверкой на заполненность), take() для извлечения объекта (с обнулением ссылки), peek() для просмотра без извлечения, isEmpty() для проверки на пустоту. Переопределяем метод toString() для удобного вывода. Демонстрируем работу коробки с разными типами данных: Integer, String, Double.

## Задача 1.3: Сравнимое
### Текст задачи
Создайте ссылочный тип Сравнимое, гарантирующий наличие по данной ссылке метода со следующими характеристиками:
• Называется "сравнить"
• Принимает объект.
• Тип принимаемого объекта может быть изменен без изменения самого Сравнимого.
• Возвращает целое число.

### Алгоритм решения
Создаем обобщенный интерфейс MyComparable<T> с методом compare(T other). Разрабатываем класс ComparableInteger, реализующий этот интерфейс для сравнения целых чисел. Реализуем логику сравнения двух чисел с возвратом отрицательного значения, если текущий объект меньше, положительного - если больше, и нуля - если равны. Демонстрируем работу интерфейса на примере сравнения нескольких чисел с возможностью определения порядка.

# Задание 2. Параметризации. Маски типов и их ограничения.
## Задача 2: Поиск максимума
### Текст задачи
Создайте метод, принимающий набор Коробок из задачи 3.1.1 и возвращающий максимальное из их значений в формате double. Принимаемые методом Коробки могут быть параметризованы любыми видами чисел.

### Алгоритм решения
Разрабатываем метод findMaxInBoxes, принимающий список коробок с числами. Используем wildcard (Box<? extends Number>) для работы с коробками любых числовых типов. Итерируем по коробкам, пропускаем пустые, преобразуем значения в double с помощью метода doubleValue(). Находим максимальное значение, обрабатываем случай, когда все коробки пусты. Демонстрируем работу метода с коробками, содержащими Integer и Double.

# Задание 3. Обобщенные методы. Автовывод типа
## Задача 3.1: Функция (map)
### Текст задачи
Разработайте такой метод, который будет принимать список значений типа T, и объект имеющий единственный метод apply. Данный метод надо применить к каждому элементу списка, и вернуть новый список значений типа P, при этом типы T и P могут совпадать, а могут не совпадать.
Используйте разработанный метод следующим образом:

Передайте в метод список со значениями:"qwerty", "asdfg", "zx", а получите список чисел, где каждое число соответствует длине каждой строки.

Передайте в метод список со значениями: 1,-3,7, а получите список в котором все отрицательные числа стали положительными, а положительные остались без изменений.

Передайте в метод список состоящий из массивов целых чисел, а получите список в котором будут только максимальные значения каждого из исходных массивов.

### Алгоритм решения
Создаем обобщенный метод map с двумя параметрами типа T и R. Принимаем список List<T> и объект Function<T,R> с методом apply(). Итерируем по исходному списку, применяем функцию к каждому элементу, результаты сохраняем в новый список List<R>. Реализуем все три примера: преобразование строк в их длины, чисел в абсолютные значения, массивов в их максимальные элементы.

## Задача 3.2: Фильтр
### Текст задачи
Разработайте такой метод, который будет принимать список значений типа T и объект имеющий единственный метод test (принимает T и возвращает boolean). Верните новый список типа T, из которого удалены все значения не прошедшие проверку условием.
Используйте разработанный метод следующим образом:

Передайте в метод список со значениями: "qwerty", "asdfg", "zx", и отфильтруйте все строки имеющие менее трех символов.

Передайте в метод список со значениями: 1,-3,7, и отфильтруйте все положительные элементы.

Передайте в метод список состоящий из массивов целых чисел, а получите список в котором будут только те массивы, в которых нет ни одного положительного элемента.

### Алгоритм решения
Разрабатываем обобщенный метод filter с параметром типа T. Принимаем список List<T> и объект Predicate<T> с методом test(). Проверяем каждый элемент списка с помощью предиката, если условие истинно - добавляем элемент в новый список. Реализуем все три примера: фильтрация строк по длине, чисел по знаку, массивов по наличию положительных элементов.

## Задача 3.3: Сокращение (reduce)
### Текст задачи
Разработайте такой метод, который будет принимать список значений типа T и способ с помощью которого список значений можно свести к одному значению типа T, которое и возвращается из метода.
Используйте разработанный метод следующим образом:

Передайте в метод список со значениями: "qwerty", "asdfg", "zx", и сформируйте одну большую строку, которая состоит из всех строк исходного списка.

Передайте в метод список со значениями: 1,-3,7, и верните сумму всех значений исходного списка.

Имеется список, состоящий из списков целых чисел, получите общее количество элементов во всех списках. Подсказка: решить задачу можно в одно действие или последовательно использовать методы из 3.3.1 и 3.3.3.
Далее необходимо изменить разработанный метод таким образом, чтобы данный метод гарантированно не возвращал null и не выбрасывал ошибок в том случае, если исходный список пуст.

### Алгоритм решения
Создаем обобщенный метод reduce с параметром типа T. Принимаем список List<T>, начальное значение identity и объект BinaryOperator<T> с методом apply(). Начинаем с identity, последовательно применяем оператор ко всем элементам списка. Обеспечиваем безопасность при пустом списке - возвращаем identity. Реализуем все три примера: конкатенация строк, суммирование чисел, подсчет общего количества элементов в списках списков.

## Задача 3.4: Коллекционирование
### Текст задачи
Разработайте такой метод, который будет возвращать коллекцию типа P со значениями типа T. Данный метод будет принимать:

Список исходных значений.

Способ создания результирующей коллекции.

Способ передачи значений исходного списка в результирующую коллекцию.
Используйте разработанный метод следующим образом:

Передайте в метод список со значениями: 1,-3,7, и верните их разбитыми на два подсписка, в одном из которых будут только положительные числа, а в другом только отрицательные.

Передайте в метод список со значениями: "qwerty", "asdfg", "zx", "qw" и верните их разбитыми на подсписки таким образом, чтобы в любом подсписке были строки только одинаковой длины.

Передайте в метод список со значениями: "qwerty", "asdfg", "qwerty", "qw" и верните набор такого вида, который не может содержать одинаковые объекты.

### Алгоритм решения
Разрабатываем обобщенный метод collect с двумя параметрами типа T и R (ограниченным Collection<T>). Принимаем список List<T>, объект Supplier<R> для создания коллекции и объект BiConsumer<R,T> для добавления элементов. Создаем коллекцию через поставщик, добавляем все элементы через аккумулятор, возвращаем результат. Реализуем все три примера: разделение чисел по знаку, группировка строк по длине, удаление дубликатов строк.
